//--------------------------------------------------------------------------------------
// By Stars XU Tianchen
//--------------------------------------------------------------------------------------

#pragma once

#include "Core/XUSGType.h"

namespace XUSG
{
	namespace ML
	{
		enum class TensorDataType
		{
			UNKNOWN	= DML_TENSOR_DATA_TYPE_UNKNOWN,
			FLOAT32	= DML_TENSOR_DATA_TYPE_FLOAT32,
			FLOAT16	= DML_TENSOR_DATA_TYPE_FLOAT16,
			UINT32	= DML_TENSOR_DATA_TYPE_UINT32,
			UINT16	= DML_TENSOR_DATA_TYPE_UINT16,
			UINT8	= DML_TENSOR_DATA_TYPE_UINT8,
			INT32	= DML_TENSOR_DATA_TYPE_INT32,
			INT16	= DML_TENSOR_DATA_TYPE_INT16,
			INT8	= DML_TENSOR_DATA_TYPE_INT8
		};

		enum class OperatorType
		{
			INVALID								= DML_OPERATOR_INVALID,
			ELEMENT_WISE_IDENTITY				= DML_OPERATOR_ELEMENT_WISE_IDENTITY,
			ELEMENT_WISE_ABS					= DML_OPERATOR_ELEMENT_WISE_ABS,
			ELEMENT_WISE_ACOS					= DML_OPERATOR_ELEMENT_WISE_ACOS,
			ELEMENT_WISE_ADD					= DML_OPERATOR_ELEMENT_WISE_ADD,
			ELEMENT_WISE_ASIN					= DML_OPERATOR_ELEMENT_WISE_ASIN,
			ELEMENT_WISE_ATAN					= DML_OPERATOR_ELEMENT_WISE_ATAN,
			ELEMENT_WISE_CEIL					= DML_OPERATOR_ELEMENT_WISE_CEIL,
			ELEMENT_WISE_CLIP					= DML_OPERATOR_ELEMENT_WISE_CLIP,
			ELEMENT_WISE_COS					= DML_OPERATOR_ELEMENT_WISE_COS,
			ELEMENT_WISE_DIVIDE					= DML_OPERATOR_ELEMENT_WISE_DIVIDE,
			ELEMENT_WISE_EXP					= DML_OPERATOR_ELEMENT_WISE_EXP,
			ELEMENT_WISE_FLOOR					= DML_OPERATOR_ELEMENT_WISE_FLOOR,
			ELEMENT_WISE_LOG					= DML_OPERATOR_ELEMENT_WISE_LOG,
			ELEMENT_WISE_LOGICAL_AND			= DML_OPERATOR_ELEMENT_WISE_LOGICAL_AND,
			ELEMENT_WISE_LOGICAL_EQUALS			= DML_OPERATOR_ELEMENT_WISE_LOGICAL_EQUALS,
			ELEMENT_WISE_LOGICAL_GREATER_THAN	= DML_OPERATOR_ELEMENT_WISE_LOGICAL_GREATER_THAN,
			ELEMENT_WISE_LOGICAL_LESS_THAN		= DML_OPERATOR_ELEMENT_WISE_LOGICAL_LESS_THAN,
			ELEMENT_WISE_LOGICAL_NOT			= DML_OPERATOR_ELEMENT_WISE_LOGICAL_NOT,
			ELEMENT_WISE_LOGICAL_OR				= DML_OPERATOR_ELEMENT_WISE_LOGICAL_OR,
			ELEMENT_WISE_LOGICAL_XOR			= DML_OPERATOR_ELEMENT_WISE_LOGICAL_XOR,
			ELEMENT_WISE_MAX					= DML_OPERATOR_ELEMENT_WISE_MAX,
			ELEMENT_WISE_MEAN					= DML_OPERATOR_ELEMENT_WISE_MEAN,
			ELEMENT_WISE_MIN					= DML_OPERATOR_ELEMENT_WISE_MIN,
			ELEMENT_WISE_MULTIPLY				= DML_OPERATOR_ELEMENT_WISE_MULTIPLY,
			ELEMENT_WISE_POW					= DML_OPERATOR_ELEMENT_WISE_POW,
			ELEMENT_WISE_CONSTANT_POW			= DML_OPERATOR_ELEMENT_WISE_CONSTANT_POW,
			ELEMENT_WISE_RECIP					= DML_OPERATOR_ELEMENT_WISE_RECIP,
			ELEMENT_WISE_SIN					= DML_OPERATOR_ELEMENT_WISE_SIN,
			ELEMENT_WISE_SQRT					= DML_OPERATOR_ELEMENT_WISE_SQRT,
			ELEMENT_WISE_SUBTRACT				= DML_OPERATOR_ELEMENT_WISE_SUBTRACT,
			ELEMENT_WISE_TAN					= DML_OPERATOR_ELEMENT_WISE_TAN,
			ELEMENT_WISE_THRESHOLD				= DML_OPERATOR_ELEMENT_WISE_THRESHOLD,
			ELEMENT_WISE_QUANTIZE_LINEAR		= DML_OPERATOR_ELEMENT_WISE_QUANTIZE_LINEAR,
			ELEMENT_WISE_DEQUANTIZE_LINEAR		= DML_OPERATOR_ELEMENT_WISE_DEQUANTIZE_LINEAR,
			ACTIVATION_ELU						= DML_OPERATOR_ACTIVATION_ELU,
			ACTIVATION_HARDMAX					= DML_OPERATOR_ACTIVATION_HARDMAX,
			ACTIVATION_HARD_SIGMOID				= DML_OPERATOR_ACTIVATION_HARD_SIGMOID,
			ACTIVATION_IDENTITY					= DML_OPERATOR_ACTIVATION_IDENTITY,
			ACTIVATION_LEAKY_RELU				= DML_OPERATOR_ACTIVATION_LEAKY_RELU,
			ACTIVATION_LINEAR					= DML_OPERATOR_ACTIVATION_LINEAR,
			ACTIVATION_LOG_SOFTMAX				= DML_OPERATOR_ACTIVATION_LOG_SOFTMAX,
			ACTIVATION_PARAMETERIZED_RELU		= DML_OPERATOR_ACTIVATION_PARAMETERIZED_RELU,
			ACTIVATION_PARAMETRIC_SOFTPLUS		= DML_OPERATOR_ACTIVATION_PARAMETRIC_SOFTPLUS,
			ACTIVATION_RELU						= DML_OPERATOR_ACTIVATION_RELU,
			ACTIVATION_SCALED_ELU				= DML_OPERATOR_ACTIVATION_SCALED_ELU,
			ACTIVATION_SCALED_TANH				= DML_OPERATOR_ACTIVATION_SCALED_TANH,
			ACTIVATION_SIGMOID					= DML_OPERATOR_ACTIVATION_SIGMOID,
			ACTIVATION_SOFTMAX					= DML_OPERATOR_ACTIVATION_SOFTMAX,
			ACTIVATION_SOFTPLUS					= DML_OPERATOR_ACTIVATION_SOFTPLUS,
			ACTIVATION_SOFTSIGN					= DML_OPERATOR_ACTIVATION_SOFTSIGN,
			ACTIVATION_TANH						= DML_OPERATOR_ACTIVATION_TANH,
			ACTIVATION_THRESHOLDED_RELU			= DML_OPERATOR_ACTIVATION_THRESHOLDED_RELU,
			CONVOLUTION							= DML_OPERATOR_CONVOLUTION,
			GEMM								= DML_OPERATOR_GEMM,
			REDUCE								= DML_OPERATOR_REDUCE,
			AVERAGE_POOLING						= DML_OPERATOR_AVERAGE_POOLING,
			LP_POOLING							= DML_OPERATOR_LP_POOLING,
			MAX_POOLING							= DML_OPERATOR_MAX_POOLING,
			ROI_POOLING							= DML_OPERATOR_ROI_POOLING,
			SLICE								= DML_OPERATOR_SLICE,
			CAST								= DML_OPERATOR_CAST,
			SPLIT								= DML_OPERATOR_SPLIT,
			JOIN								= DML_OPERATOR_JOIN,
			PADDING								= DML_OPERATOR_PADDING,
			VALUE_SCALE_2D						= DML_OPERATOR_VALUE_SCALE_2D,
			UPSAMPLE_2D							= DML_OPERATOR_UPSAMPLE_2D,
			GATHER								= DML_OPERATOR_GATHER,
			SPACE_TO_DEPTH						= DML_OPERATOR_SPACE_TO_DEPTH,
			DEPTH_TO_SPACE						= DML_OPERATOR_DEPTH_TO_SPACE,
			TILE								= DML_OPERATOR_TILE,
			TOP_K								= DML_OPERATOR_TOP_K,
			BATCH_NORMALIZATION					= DML_OPERATOR_BATCH_NORMALIZATION,
			MEAN_VARIANCE_NORMALIZATION			= DML_OPERATOR_MEAN_VARIANCE_NORMALIZATION,
			LOCAL_RESPONSE_NORMALIZATION		= DML_OPERATOR_LOCAL_RESPONSE_NORMALIZATION,
			LP_NORMALIZATION					= DML_OPERATOR_LP_NORMALIZATION,
			RNN									= DML_OPERATOR_RNN,
			LSTM								= DML_OPERATOR_LSTM,
			GRU									= DML_OPERATOR_GRU
		};

		enum class TensorFlag
		{
			NONE	= DML_TENSOR_FLAG_NONE,
			MANAGED	= DML_TENSOR_FLAG_OWNED_BY_DML,
		};

		DEFINE_ENUM_FLAG_OPERATORS(TensorFlag);

		enum class ExecutionFlag
		{
			NONE								= DML_EXECUTION_FLAG_NONE,
			ALLOW_HALF_PRECISION_COMPUTATION	= DML_EXECUTION_FLAG_ALLOW_HALF_PRECISION_COMPUTATION,
			DISABLE_META_COMMANDS				= DML_EXECUTION_FLAG_DISABLE_META_COMMANDS,
			DESCRIPTORS_VOLATILE				= DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE,
		};

		DEFINE_ENUM_FLAG_OPERATORS(ExecutionFlag);

		enum class ConvolutionMode
		{
			CONVOLUTION			= DML_CONVOLUTION_MODE_CONVOLUTION,
			CROSS_CORRELATION	= DML_CONVOLUTION_MODE_CROSS_CORRELATION
		};

		enum class ConvolutionDirection
		{
			FORWARD		= DML_CONVOLUTION_DIRECTION_FORWARD,
			BACKWARD	= DML_CONVOLUTION_DIRECTION_BACKWARD
		};

		enum class InterpolationType
		{
			NEAREST_NEIGHBOR	= DML_INTERPOLATION_MODE_NEAREST_NEIGHBOR,
			LINEAR				= DML_INTERPOLATION_MODE_LINEAR
		};

		using Device = com_ptr<IDMLDevice>;
		using CommandRecorder = com_ptr<IDMLCommandRecorder>;
		using Dispatchable = com_ptr<IDMLDispatchable>;
		using BindingTable = com_ptr<IDMLBindingTable>;

		using BufferTensorDesc = DML_BUFFER_TENSOR_DESC;
		using TensorDesc = DML_TENSOR_DESC;
		using BufferBinding = DML_BUFFER_BINDING;
		using ArrayBinding = DML_BUFFER_ARRAY_BINDING;
		using BindingDesc = DML_BINDING_DESC;

		struct OperatorDesc : public DML_OPERATOR_DESC
		{
			OperatorDesc(OperatorType type, const void* pDesc)
			{
				Type = static_cast<DML_OPERATOR_TYPE>(type);
				Desc = pDesc;
			}
		};

		using ElementWiseIdentity = DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC;
		using ElementWiseAbs = DML_ELEMENT_WISE_ABS_OPERATOR_DESC;
		using ElementWiseAcos = DML_ELEMENT_WISE_ACOS_OPERATOR_DESC;
		using ElementWiseAdd = DML_ELEMENT_WISE_ADD_OPERATOR_DESC;
		using ElementWiseAsin = DML_ELEMENT_WISE_ASIN_OPERATOR_DESC;
		using ElementWiseAtan = DML_ELEMENT_WISE_ATAN_OPERATOR_DESC;
		using ElementWiseCeil = DML_ELEMENT_WISE_CEIL_OPERATOR_DESC;
		using ElementWiseClip = DML_ELEMENT_WISE_CLIP_OPERATOR_DESC;
		using ElementWiseCos = DML_ELEMENT_WISE_COS_OPERATOR_DESC;
		using ElementWiseDivide = DML_ELEMENT_WISE_DIVIDE_OPERATOR_DESC;
		using ElementWiseExp = DML_ELEMENT_WISE_EXP_OPERATOR_DESC;
		using ElementWiseFloor = DML_ELEMENT_WISE_FLOOR_OPERATOR_DESC;
		using ElementWiseLog = DML_ELEMENT_WISE_LOG_OPERATOR_DESC;
		using ElementWiseLogicalAnd = DML_ELEMENT_WISE_LOGICAL_AND_OPERATOR_DESC;
		using ElementWiseLogicalEquals = DML_ELEMENT_WISE_LOGICAL_EQUALS_OPERATOR_DESC;
		using ElementWiseLogicalGreater = DML_ELEMENT_WISE_LOGICAL_GREATER_THAN_OPERATOR_DESC;
		using ElementWiseLogicalLessThan = DML_ELEMENT_WISE_LOGICAL_LESS_THAN_OPERATOR_DESC;
		using ElementWiseLogicalNot = DML_ELEMENT_WISE_LOGICAL_NOT_OPERATOR_DESC;
		using ElementWiseLogicalOr = DML_ELEMENT_WISE_LOGICAL_OR_OPERATOR_DESC;
		using ElementWiseLogicalXor = DML_ELEMENT_WISE_LOGICAL_XOR_OPERATOR_DESC;
		using ElementWiseMax = DML_ELEMENT_WISE_MAX_OPERATOR_DESC;
		using ElementWiseMean = DML_ELEMENT_WISE_MEAN_OPERATOR_DESC;
		using ElementWiseMin = DML_ELEMENT_WISE_MIN_OPERATOR_DESC;
		using ElementWiseMultiply = DML_ELEMENT_WISE_MULTIPLY_OPERATOR_DESC;
		using ElementWisePow = DML_ELEMENT_WISE_POW_OPERATOR_DESC;
		using ElementWiseConstantPow = DML_ELEMENT_WISE_CONSTANT_POW_OPERATOR_DESC;
		using ElementWiseRecip = DML_ELEMENT_WISE_RECIP_OPERATOR_DESC;
		using ElementWiseSin = DML_ELEMENT_WISE_SIN_OPERATOR_DESC;
		using ElementWiseSqrt = DML_ELEMENT_WISE_SQRT_OPERATOR_DESC;
		using ElementWiseSubtract = DML_ELEMENT_WISE_SUBTRACT_OPERATOR_DESC;
		using ElementWiseTan = DML_ELEMENT_WISE_TAN_OPERATOR_DESC;
		using ElementWiseThreshold = DML_ELEMENT_WISE_THRESHOLD_OPERATOR_DESC;
		using ElementWiseQuantizeLinear = DML_ELEMENT_WISE_QUANTIZE_LINEAR_OPERATOR_DESC;
		using ElementWiseDequantizeLinear = DML_ELEMENT_WISE_DEQUANTIZE_LINEAR_OPERATOR_DESC;

		using ActivationELU = DML_ACTIVATION_ELU_OPERATOR_DESC;
		using ActivationHardMax = DML_ACTIVATION_HARDMAX_OPERATOR_DESC;
		using ActivationHardSigmoid = DML_ACTIVATION_HARD_SIGMOID_OPERATOR_DESC;
		using ActivationIdentity = DML_ACTIVATION_IDENTITY_OPERATOR_DESC;
		using ActivationLeakyRELU = DML_ACTIVATION_LEAKY_RELU_OPERATOR_DESC;
		using ActivationLinear = DML_ACTIVATION_LINEAR_OPERATOR_DESC;
		using ActivationLogSoftmax = DML_ACTIVATION_LOG_SOFTMAX_OPERATOR_DESC;
		using ActivationParameterizedRELU = DML_ACTIVATION_PARAMETERIZED_RELU_OPERATOR_DESC;
		using ActivationParametricSoftplus = DML_ACTIVATION_PARAMETRIC_SOFTPLUS_OPERATOR_DESC;
		using ActivationRELU = DML_ACTIVATION_RELU_OPERATOR_DESC;
		using ActivationScaledELU = DML_ACTIVATION_SCALED_ELU_OPERATOR_DESC;
		using ActivationScaledTanh = DML_ACTIVATION_SCALED_TANH_OPERATOR_DESC;
		using ActivationSigmoid = DML_ACTIVATION_SIGMOID_OPERATOR_DESC;
		using ActivationSoftmax = DML_ACTIVATION_SOFTMAX_OPERATOR_DESC;
		using ActivationSoftplus = DML_ACTIVATION_SOFTPLUS_OPERATOR_DESC;
		using ActivationSoftsign = DML_ACTIVATION_SOFTSIGN_OPERATOR_DESC;
		using ActivationTanh = DML_ACTIVATION_TANH_OPERATOR_DESC;
		using ActivationThresholdRELU = DML_ACTIVATION_THRESHOLDED_RELU_OPERATOR_DESC;

		struct ConvolutionOperator : public DML_CONVOLUTION_OPERATOR_DESC
		{
			ConvolutionOperator(const TensorDesc* pInputTensor, const TensorDesc* pFilterTensor,
				const TensorDesc* pBiasTensor, const TensorDesc* pOutputTensor,
				ConvolutionMode mode, ConvolutionDirection direction, uint32_t dimensionCount,
				const uint32_t* pStrides, const uint32_t* pDilations, const uint32_t* pStartPadding,
				const uint32_t* pEndPadding, const uint32_t* pOutputPadding, uint32_t groupCount,
				const OperatorDesc* pFusedActivation)
			{
				InputTensor = pInputTensor;
				FilterTensor = pFilterTensor;
				BiasTensor = pBiasTensor;
				OutputTensor = pOutputTensor;
				Mode = static_cast<DML_CONVOLUTION_MODE>(mode);
				Direction = static_cast<DML_CONVOLUTION_DIRECTION>(direction);
				DimensionCount = dimensionCount;
				Strides = pStrides;
				Dilations = pDilations;
				StartPadding = pStartPadding;
				EndPadding = pEndPadding;
				OutputPadding = pOutputPadding;
				GroupCount = groupCount;
				FusedActivation = pFusedActivation;
			}
		};
		using GEMMOperator = DML_GEMM_OPERATOR_DESC;
		using ReduceOperator = DML_REDUCE_OPERATOR_DESC;

		using AveragePooling = DML_AVERAGE_POOLING_OPERATOR_DESC;
		using LpPooling = DML_LP_POOLING_OPERATOR_DESC;
		using MaxPooling = DML_MAX_POOLING_OPERATOR_DESC;
		using RoiPooling = DML_ROI_POOLING_OPERATOR_DESC;

		using SliceOperator = DML_SLICE_OPERATOR_DESC;
		using CastOperator = DML_CAST_OPERATOR_DESC;
		using SplitOperator = DML_SPLIT_OPERATOR_DESC;
		using JoinOperator = DML_JOIN_OPERATOR_DESC;
		using PaddingOperator = DML_PADDING_OPERATOR_DESC;
		using ValueScale2D = DML_VALUE_SCALE_2D_OPERATOR_DESC;
		struct Upsample2D : public DML_UPSAMPLE_2D_OPERATOR_DESC
		{
			Upsample2D(const TensorDesc* pInputTensor, const TensorDesc* pOutputTensor,
				uint32_t scaleSizeX, uint32_t scaleSizeY, InterpolationType interpolationType)
			{
				InputTensor = pInputTensor;
				OutputTensor = pOutputTensor;
				ScaleSize.Width = scaleSizeX;
				ScaleSize.Height = scaleSizeY;
				InterpolationMode = static_cast<DML_INTERPOLATION_MODE>(interpolationType);
			}
		};
		using GatherOperator = DML_GATHER_OPERATOR_DESC;
		using SpaceToDepth = DML_SPACE_TO_DEPTH_OPERATOR_DESC;
		using DepthToSpace = DML_DEPTH_TO_SPACE_OPERATOR_DESC;
		using TileOperator = DML_TILE_OPERATOR_DESC;
		using TopKOperator = DML_TOP_K_OPERATOR_DESC;

		using BatchNormalization = DML_BATCH_NORMALIZATION_OPERATOR_DESC;
		using MeanVarianceNormalization = DML_MEAN_VARIANCE_NORMALIZATION_OPERATOR_DESC;
		using LocalResponseNormalization = DML_LOCAL_RESPONSE_NORMALIZATION_OPERATOR_DESC;
		using LpNormalization = DML_LP_NORMALIZATION_OPERATOR_DESC;
		
		using RNNOperator = DML_RNN_OPERATOR_DESC;
		using LSTMOperator = DML_LSTM_OPERATOR_DESC;
		using GRUOperator = DML_GRU_OPERATOR_DESC;
	}
}
